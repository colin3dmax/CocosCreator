module.exports = "\n#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec2 v_texCoord;\nuniform float time;\nuniform vec2 mouse_touch;\nuniform vec2 resolution;\nconst float minRStart = -2.0;\nconst float maxRStart = 1.0;\nconst float minIStart = -1.0;\nconst float maxIStart = 1.0;\nconst int maxIterations = 50;\n// Immaginary number: has a real and immaginary part\nstruct complexNumber\n{\n\tfloat r;\n\tfloat i;\n};\nvoid main( void ) {\n\tfloat minR = minRStart; // change these in order to zoom\n\tfloat maxR = maxRStart;\n\tfloat minI = minIStart;\n\tfloat maxI = maxIStart;\n\t\n\tvec3 col = vec3(0,0,0);\n\t\n\tvec2 pos = gl_FragCoord.xy / resolution;\n\t\n\t// The complex number of the current pixel.\n\tcomplexNumber im;\n\tim.r = minR + (maxR-minR)*pos.x; // LERP within range\n\tim.i = minI + (maxI-minI)*pos.y;\n\t\n\tcomplexNumber z;\n\tz.r = im.r;\n\tz.i = im.i;\n\t\n\tbool def = true; // is the number (im) definite?\n\tint iterations = 0;\n\tfor(int i = 0; i< maxIterations; i++)\n\t{\n\t\tif(sqrt(z.r*z.r + z.i*z.i) > 2.0) // abs(z) = distance from origo\n\t\t{\n\t\t\tdef = false;\n\t\t\titerations = i; \n\t\t\tbreak;\n\t\t}\n\t\t// Mandelbrot formula: zNew = zOld*zOld + im\n\t\t// z = (a+bi) => z*z = (a+bi)(a+bi) = a*a - b*b + 2abi\n\t\tcomplexNumber zSquared; \n\t\tzSquared.r = z.r*z.r - z.i*z.i; // real part: a*a - b*b\n\t\tzSquared.i = 2.0*z.r*z.i; // immaginary part: 2abi\n\t\t// add: rSquared + im -> simple: just add the real and immaginary parts\n\t\tz.r = zSquared.r + im.r; // add real parts\n\t\tz.i = zSquared.i + im.i; // add immaginary parts\n\t}\n\tif(def) // it is definite => colour it black\n\t\tcol.rgb = vec3(0,0,0);\n\telse // the number grows to infinity => colour it by the number of iterations \n\t{\n\t\tfloat i = float(iterations)/float(maxIterations);\n\t\tcol.r = smoothstep(0.0,0.5, i);\n\t\tcol.g = smoothstep(0.0,1.0,i);\n\t\tcol.b = smoothstep(0.3,1.0, i);\n\t}\n\tgl_FragColor.rgb = col;\n}\n\n";